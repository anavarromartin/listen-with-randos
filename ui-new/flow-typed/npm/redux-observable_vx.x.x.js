// flow-typed signature: 4612045e2ef510af7a2e7579ff0b97b5
// flow-typed version: <<STUB>>/redux-observable_v^1.0.0/flow_v0.82.0

/**
 * This is an autogenerated libdef stub for:
 *
 *   'redux-observable'
 *
 * Fill this stub out by replacing all the `any` types.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */

import {Observable, Subject} from 'rxjs'
import type {Middleware, Dispatch} from 'redux';

type redux$Action = { +type: $Subtype<string> };

declare module 'redux-observable' {
  declare export class ActionsObservable<+T: redux$Action> extends Observable<T> {
    static of(item1: T, scheduler?: rxjs$SchedulerClass): ActionsObservable<T>;
    static of(item1: T, item2: T, scheduler?: rxjs$SchedulerClass): ActionsObservable<T>;
    static of(item1: T, item2: T, item3: T, scheduler?: rxjs$SchedulerClass): ActionsObservable<T>;
    static of(item1: T, item2: T, item3: T, item4: T, scheduler?: rxjs$SchedulerClass): ActionsObservable<T>;
    static of(item1: T, item2: T, item3: T, item4: T, item5: T, scheduler?: rxjs$SchedulerClass): ActionsObservable<T>;
    static of(item1: T, item2: T, item3: T, item4: T, item5: T, item6: T, scheduler?: rxjs$SchedulerClass): ActionsObservable<T>;
    static of(...array: Array<T | rxjs$SchedulerClass>): ActionsObservable<T>;

    static from(ish: rxjs$ObservableInput<T>, scheduler?: rxjs$SchedulerClass): ActionsObservable<T>;
    static from(ish: Array<T>, scheduler?: rxjs$SchedulerClass): ActionsObservable<T>;

    constructor(input$: Observable<T>): void;

    lift<R: redux$Action>(operator: rxjs$Operator<T, R>): ActionsObservable<R>;
    lift<R>(operator: rxjs$Operator<T, R>): Observable<R>;

    ofType<R: T>(...keys: Array<$PropertyType<R, 'type'>>): ActionsObservable<R>;
  }

  declare export class StateObservable<S> extends Observable<S> {
    source: Subject<S>;
    constructor(stateSubject: Subject<S>, initializeState: S): void;

    value: S;
  }

  declare export type Epic<A, S = any, D = any, O: A = A> =
    (action$: ActionsObservable<A>, state$: StateObservable<S>, dependencies: D) => Observable<O>;

  declare export type EpicMiddleware<A, S = any, D = any, O = A> =
    & Middleware<S, A, Dispatch<redux$Action>>
    & { run(rootEpic: Epic<A, S, D, O>): void };

  declare export type EpicMiddlewareOptions<D = any> = {
    dependencies?: D
  };

  declare export function createEpicMiddleware<A, S, D>(options?: EpicMiddlewareOptions<D>): EpicMiddleware<A, S, D>;

  declare export function combineEpics<A, S, D>(...epics: Array<Epic<A, S, D>>): Epic<A, S, D>;

  declare export function ofType<
    A: redux$Action,
    R: A,
    K: $PropertyType<R, 'type'>
  >(...key: Array<K>): (source: Observable<A>) => Observable<R>;
}
